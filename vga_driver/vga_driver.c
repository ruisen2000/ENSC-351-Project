
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/errno.h>
#include <linux/slab.h>
#include <linux/fs.h>

#include <linux/io.h>
#include <asm/uaccess.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include <linux/list.h>
#include <linux/wait.h>

#include <linux/cdev.h>
#include <linux/kfifo.h>

#include <linux/interrupt.h>
#include <asm/irq.h>
#include <linux/signal.h>
#include "vga_ioctl.h"

//We added this
#include <linux/dma-mapping.h>

static struct file_operations vga_fops;



/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("John Williams - PetaLogix Qld Pty Ltd <john.williams@petalogix.com>");
MODULE_DESCRIPTION
    ("vga_driver - loadable module template generated by petalinux-new-module");

#define DRIVER_NAME "vga_driver"




/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
unsigned myint = 0xdeadbeef;
char *mystr = "default";

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);

struct vga_driver_local {
	
//Below code was incerted from TASK2 hints
	int major;
	int minor;
	unsigned long mem_start;
	unsigned long mem_end;
	void __iomem *base_addr;
	void *fb_virt; // Kernel Space memory pointer
	dma_addr_t fb_phys; // Physical Address
	struct device *dev; //Representation of VGA Device
	struct cdev *cdev;



/* From Template
	int irq;
	unsigned long mem_start;
	unsigned long mem_end;
	void __iomem *base_addr; */

};

struct vga_driver_local *vga_local;



//Added this
static int vga_mmap(struct file *filp, struct vm_area_struct *vma){

unsigned long pfn;
pfn = dma_to_pfn(vga_local->dev, vga_local->fb_phys); //where vma is virtual memory of user space


unsigned long off;
off = vma->vm_pgoff; //Dont think this should be here

vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot); //Make virtual memory volatile


if (remap_pfn_range(vma, vma->vm_start, pfn + off, vma->vm_end - vma->vm_start,vma->vm_page_prot)){ //alocates all memory that the VGA driver needs

	return -EAGAIN;
}
	

return 0;

}

/////////Probe from vga
static int __devinit vga_probe(struct platform_device *pdev)
{
	struct resource *r_mem; /* IO mem resources Part A*/
	struct device *dev = &pdev->dev; 

	int rc = 0;
	dev_t  devno;
	int err;
		
	/* dev_info is a logging function part of the platform driver API */
	dev_info(dev, "Device Tree Probing\n"); //Part B

	/* Get iospace for the device */
	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0); //Part C
	if (!r_mem) {
		dev_err(dev, "invalid address\n");
		return -ENODEV;
	}
	
	/* Allocate space for driver data structure
	 * note the use of kmalloc - malloc (and all other C library functions) is
	 * unavailable in kernel code */
	vga_local = (struct vga_driver_local *) kmalloc(sizeof(struct vga_driver_local), GFP_KERNEL); //Part D
	if (!vga_local) {
		dev_err(dev, "Cound not allocate vga device\n");
		return -ENOMEM;
	}
	
	dev_set_drvdata(dev, vga_local);
	
	vga_local->mem_start = r_mem->start;
	vga_local->mem_end = r_mem->end;

	if (!request_mem_region(vga_local->mem_start,
				vga_local->mem_end - vga_local->mem_start + 1,
				DRIVER_NAME)) {
		dev_err(dev, "Couldn't lock memory region at %p\n",
			(void *)vga_local->mem_start);
		rc = -EBUSY;
		goto error1;
	}
/*
	// Request IRQ, commented out becasue not part of part 7
	vga_local->irq = platform_get_irq(pdev, 0);
	rc = request_irq(vga_local->irq, (void*)vga_interrupt, 0, DRIVER_NAME, dev);
	if (rc) {
		dev_err(dev, "can't get assigned irq %i\n", vga_local->irq);
		goto error3;
	} else {
		dev_info(dev, "assigned irq number %i\n", vga_local->irq);
	}
*/

	/* Allocate I/O memory */ //Part E
	vga_local->base_addr = ioremap(vga_local->mem_start, vga_local->mem_end - vga_local->mem_start + 1);
	if (!vga_local->base_addr) {
		dev_err(dev, "vga: Could not allocate iomem\n");
		rc = -EIO;
		goto error2;
	}





 	dev_info(dev, "Registering character device\n");
 
    if ((alloc_chrdev_region(&devno, 0, 1, "vga")) < 0)  {
        goto error3;
	}

	vga_local->fb_virt =dma_alloc_coherent(dev,BUFFER_SIZE, &vga_local->fb_phys, GFP_KERNEL);//Part F
	iowrite32(vga_local->fb_phys,vga_local->base_addr);//Part G


	/* Fill in driver data structure */
    vga_local->major = MAJOR(devno);
    vga_local->minor = MINOR(devno);
    		    
	dev_info(dev, "Initializing character device\n");
    		     	
    vga_local->cdev = cdev_alloc();
	vga_local->cdev->owner = THIS_MODULE;
	vga_local->cdev->ops = &vga_fops;
	err = cdev_add (vga_local->cdev, devno, 1);

	/* Print driver info (addresses, major and minor num) */
	dev_info(dev,"vga at 0x%08x mapped to 0x%08x\nMajor: %d, Minor %d\n",
		(unsigned int __force)vga_local->mem_start,
		(unsigned int __force)vga_local->base_addr,
		vga_local->major, vga_local->minor);





	return 0;

/* Error handling for probe function
 * - this is one of very few cases where goto statements are a good idea
 * - when an error happens that prevents the driver from continuing to
 *   register/allocate resources, we need to undo any previous allocations
 *   that succeeded (in the reverse order)
 */
/*error4: // Undo 'request_irq()'
	free_irq(vga_local->irq, dev); */

error3: // Undo 'ioremap()'
	iounmap((void *)(vga_local->base_addr));
error2:
	release_mem_region(vga_local->mem_start, vga_local->mem_end - vga_local->mem_start + 1);
error1:
	kfree(vga_local);
	dev_set_drvdata(dev, NULL);
	return rc;
}
////////////////end




// this is the vga version of ioctl modified to work on vga
static long vga_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {

  struct vga_data {
    __u32 offset;
    __u32 data;
  };

  struct vga_data data;


	/* printf (along with other C library functions) is not available in
	 * kernel code, but printk is almost identical */
	printk(KERN_ALERT "Starting IOCTL... \n");

	if (copy_from_user(&data, (void *)arg, sizeof(struct vga_data))) {
				printk(KERN_ALERT "***Unsuccessful transfer of ioctl argument...\n");
				return -EFAULT;
			}
//printk(KERN_ALERT "copy from user: \n");
//printk(KERN_ALERT "The value of offset is %u \n", data.offset);


	switch (cmd) {
		case VGA_WRITE_REG:
			
			iowrite32(data.data,((char *)vga_local->base_addr)+(data.offset)); //write to register
			//printk(KERN_ALERT "writing to register: The value of data is %u \n\n", data.data);
			break;

		case VGA_READ_REG:
			data.data = ioread32( ((char *)vga_local->base_addr)+(data.offset) );
			if (copy_to_user( (void *)arg, &data, sizeof(struct vga_data))) { 
			  printk(KERN_ALERT "***Unsuccessful transfer of ioctl argument...\n");
				return -EFAULT;
		}
			break;

		default:
			printk(KERN_ALERT "***Invalid ioctl command...\n");
			return -EINVAL;
	}

	return 0;

}

//end of ioctl

static int vga_open(struct inode *inode, struct file *file){ //(struct inode *inode, struct file *file) parameters from the vga.ko

return 0;

}

static int vga_release(struct inode *inode, struct file *file){ //(struct inode *inode, struct file *file) parameters from the vga.ko

return 0;

}




/*
static irqreturn_t vga_driver_irq(int irq, void *lp)
{
	printk("vga_driver interrupt\n");
	return IRQ_HANDLED;
}
*/


static int __devexit vga_driver_remove(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct vga_driver_local *lp = dev_get_drvdata(dev);
	//free_irq(lp->irq, lp);
	dma_free_coherent(dev,BUFFER_SIZE,vga_local->fb_virt, &vga_local->fb_phys);
	release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}

#ifdef CONFIG_OF
static struct of_device_id vga_driver_of_match[] __devinitdata = {
	{ .compatible = "xlnx,svga-core-1.00.a", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, vga_driver_of_match);
#else
# define vga_driver_of_match
#endif


static struct platform_driver vga_driver_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= vga_driver_of_match,
	},
	.probe		= vga_probe,
	.remove		= __devexit_p(vga_driver_remove),
};


static int __init vga_driver_init(void)
{
	printk("<1>Hello module world.\n");
	printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
	       mystr);

	return platform_driver_register(&vga_driver_driver);
}


static void __exit vga_driver_exit(void)
{
	platform_driver_unregister(&vga_driver_driver);
	printk(KERN_ALERT "Goodbye module world.\n");
}

static struct file_operations vga_fops = {

.open = vga_open,
.release = vga_release,
.unlocked_ioctl = vga_ioctl,
.mmap = vga_mmap,

};

module_init(vga_driver_init);
module_exit(vga_driver_exit);

